<!DOCTYPE html>

<html>
	<head>
		<title>Pure HTML/JS Chess</title>
	</head>
	<body style="background-color: black;">
		<div id="board">
		</div>
	</body>


	<script>


		const SVG = {
			//BLACK
			KING_B: "https://upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Chess_fdt45.svg/800px-Chess_fdt45.svg.png",
			QUEEN_B: "https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Chess_gdt45.svg/800px-Chess_gdt45.svg.png",
			ROOK_B: "https://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Chess_mdt45.svg/800px-Chess_mdt45.svg.png",
			
			KNIGHT_B: "https://upload.wikimedia.org/wikipedia/commons/thumb/4/43/Chess_Ndt45.svg/800px-Chess_Ndt45.svg.png",
			POWN_B: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Chess_hdt45.svg/800px-Chess_hdt45.svg.png",
			BISHOP_B: "https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Chess_Bdt45.svg/800px-Chess_Bdt45.svg.png",

			//WHITE
			KING_W: "https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/Chess_klt45.svg/800px-Chess_klt45.svg.png",
			QUEEN_W: "https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Chess_qlt45.svg/800px-Chess_qlt45.svg.png",
			ROOK_W: "https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Chess_rlt45.svg/800px-Chess_rlt45.svg.png",
			KNIGHT_W: "https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Chess_nlt45.svg/800px-Chess_nlt45.svg.png",
			POWN_W: "https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Chess_plt45.svg/800px-Chess_plt45.svg.png",
			BISHOP_W: "https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Chess_blt45.svg/800px-Chess_blt45.svg.png",

		}

		const COLORS  = {BLACK: 1, WHITE: -1}

		const CELLS = 64;
		const CELLSIZE= 60 //in pixels
		
		function clearPlaceHolder(board){
			for(let i=0; i < CELLS; i++){
				if (board[i]  && board[i].placeHolder )
				board[i] = board[i].for_

			}
			
		}

		const PIECES = {
			PAWN: 0,
			KING: 1,
			QUEEN: 2,
			ROOK: 3,
			BISHOP: 4,
			KIGHT: 5,
		}

		class Piece{
			row; col; moveStyles; hasMoved; image; placeHolder; color; for_; game;


			constructor(row, col, piece, moveStyles, color, image){
				this.col = col
				this.row = row
				this.piece = piece
				this.moveStyles = moveStyles
				this.hasMoved = false
				this.image = image
				this.placeHolder = false
				this.color = color

			}

			setPosition(row, col){
				this.row = row
				this.col = col

				return this
			}

			move (row, col){
				this.setPosition(row, col)
				this.hasMoved = true
			}



			getPossibleMoves(boardState){
				if (this.piece === PIECES.PAWN){
					const moves = []
					if (!this.game.board[this.col + (this.row + this.color)*8])
						moves.push({col: this.col, row: this.row + this.color})
					if (!this.hasMoved && !this.game.board[this.col + (this.row + 2 * this.color)*8])
						moves.push({col: this.col, row: this.row + 2* this.color})
					if (this.col > 0 && this.game.board[this.col-1 + (this.row + this.color)*8])
						moves.push({col: this.col-1, row: this.row + this.color})
					
					if (this.col  < 8 && this.game.board[this.col+1 + (this.row + this.color)*8])
						moves.push({col: this.col+1, row: this.row + this.color})
					
					return moves
				}

				return this.moveStyles.map((move)=>{
					if (move.x === Infinity){
						const moremoves  = []
						if (move.y === Infinity)
							for(let i=1; i < 8; i++)
								moremoves.push({col: this.col + i, row: this.row - i})
						else if (move.y === -Infinity)
							for(let i=1; i < 8; i++)
								moremoves.push({col: this.col + i, row: this.row  + i})
						else 
							for(let i=1; i < 8; i++)
								moremoves.push({col: this.col + i, row: this.row})
						return moremoves
					}
					else if (move.x === -Infinity){
						const moremoves  = []
						if (move.y === -Infinity)
							for(let i=1; i < 8; i++)
								moremoves.push({col: this.col - i, row: this.row - i})
						else if (move.y === Infinity)
							for(let i=1; i < 8; i++)
								moremoves.push({col: this.col - i, row: this.row + i})
						else 
							for(let i=1; i < 8; i++)
								moremoves.push({col: this.col - i, row: this.row})
						return moremoves
					}
					else if (move.y === Infinity){
						const moremoves  = []
						for(let i=1; i < 8; i++)
							moremoves.push({col: this.col, row: this.row - i})
						return moremoves
					}
					else if (move.y === -Infinity){
						const moremoves  = []
						for(let i=1; i < 8; i++)
							moremoves.push({col: this.col, row: this.row + i})
						return moremoves
					}
					else{
						const col = this.col + move.x
						const row = this.row + move.y
						return  {
							col, row
						}
					}
				})
			}

			toGame(game){
				this.game = game
				return this
			}

			toPlaceHolder(for_){
				this.placeHolder = true
				this.for_ = for_
				return this
			}

			render (cell){
				if (this.placeHolder){
					if(this.for_){
						cell.style.backgroundColor = "#dd6666"
						this.for_.render(cell)

					}else{
						const x =  document.createElement("h3")
						x.textContent = "X"
						cell.appendChild(x)
					}

					cell.onclick = (e)=>{
						const game  = this.game
						const index = this.col + this.row * 8
						game.board[index] = game.activePiece
						game.board[game.activePiece.row * 8 + game.activePiece.col] = undefined
						game.activePiece.move(this.row, this.col)
						this.for_  = undefined
						game.turn *= -1
						clearPlaceHolder(game.board)
						game.renderBoard()
					}

				}else{
					const image = document.createElement("img")
					image.src = this.image
					image.width = CELLSIZE
					image.height = CELLSIZE

					cell.onclick = (e)=>{
						const game = this.game
						if (!(game.turn === this.color))
							return 
						game.activePiece = this
						// cell.style.backgroundColor = "#55bb55"
						clearPlaceHolder(game.board)
						const moves = this.getPossibleMoves(this.board)
						const filteredMoves = []

						for(const move of moves)
							if (move.length){
								for (const movee of move){
									if(game.board[movee.col + movee.row * 8] && !(game.board[movee.col + movee.row * 8].isplaceHolder) ){
										filteredMoves.push(movee)
										break
									}
									filteredMoves.push(movee)
									
								}
							}else {
								filteredMoves.push(move)
							}

						for (const move of filteredMoves){
							if((move.col < 8 && move.row < 8) && (move.col > -1 && move.row > -1)){
								const index = move.row * 8 + move.col 
								const plh = (new  Piece(move.row, move.col, undefined, undefined)).toPlaceHolder(game.board[index]).toGame(game)
								game.board[index] = game.board[index] && this.color===game.board[index].color? game.board[index]: plh
							}
						}
						cell.replaceChildren([image])
						game.renderBoard()
					}
						cell.appendChild(image)

				}
			}

		}

		//tis is the initial board state for a classical chess game
		const INITIAL_BOARD_STATE = [
				// Rank 8 (black back rank)
				new Piece(0, 0, PIECES.ROOK, [{x: Infinity, y:0}, {x: -Infinity, y:0},  {y: Infinity, x:0}, {y: -Infinity, x:0}], COLORS.BLACK, SVG.ROOK_B),
				new Piece(0, 1, PIECES.KIGHT, [{x: 2, y:1}, {x: -2, y:1}, {x: 2, y:-1}, {x: -2, y:-1}, {y: 2, x:1}, {y: -2,x:1}, {y: 2, x:-1}, {y: -2,x:-1}], COLORS.BLACK, SVG.KNIGHT_B),
				new Piece(0, 2, PIECES.BISHOP, [{x: Infinity, y:Infinity}, {x: -Infinity, y: Infinity},{y: -Infinity, x: -Infinity}, {y: -Infinity, x: Infinity}], COLORS.BLACK, SVG.BISHOP_B),
				new Piece(0, 3, PIECES.QUEEN, [{x: Infinity, y:0}, {x: -Infinity, y:0}, {x: Infinity, y:Infinity}, {x: -Infinity, y: Infinity}, {y: Infinity, x:0}, {y: -Infinity, x:0}, {y: -Infinity, x: -Infinity}, {y: -Infinity, x: Infinity}], COLORS.BLACK, SVG.QUEEN_B),
				new Piece(0, 4, PIECES.KING, [{x: 1, y:0}, {x: -1, y:0}, {x: 1, y:1}, {x: -1, y: 1}, {y: 1, x:0}, {y: -1, x:0}, {y: -1, x:-1}, {y: -1, x: 1}], COLORS.BLACK, SVG.KING_B),
				new Piece(0, 5, PIECES.BISHOP, [{x: Infinity, y:Infinity}, {x: -Infinity, y: Infinity},{y: -Infinity, x: -Infinity}, {y: -Infinity, x: Infinity}], COLORS.BLACK, SVG.BISHOP_B),
				new Piece(0, 6, PIECES.KIGHT, [{x: 2, y:1}, {x: -2, y:1}, {x: 2, y:-1}, {x: -2, y:-1}, {y: 2, x:1}, {y: -2,x:1}, {y: 2, x:-1}, {y: -2,x:-1}], COLORS.BLACK, SVG.KNIGHT_B),
				new Piece(0, 7, PIECES.ROOK, [{x: Infinity, y:0}, {x: -Infinity, y:0},  {y: Infinity, x:0}, {y: -Infinity, x:0}], COLORS.BLACK, SVG.ROOK_B),

				// Rank 7 (black pawns)
				new Piece(1, 0, PIECES.PAWN, [], COLORS.BLACK, SVG.POWN_B),
				new Piece(1, 1, PIECES.PAWN, [], COLORS.BLACK, SVG.POWN_B),
				new Piece(1, 2, PIECES.PAWN, [], COLORS.BLACK, SVG.POWN_B),
				new Piece(1, 3, PIECES.PAWN, [], COLORS.BLACK, SVG.POWN_B),
				new Piece(1, 4, PIECES.PAWN, [], COLORS.BLACK, SVG.POWN_B),
				new Piece(1, 5, PIECES.PAWN, [], COLORS.BLACK, SVG.POWN_B),
				new Piece(1, 6, PIECES.PAWN, [], COLORS.BLACK, SVG.POWN_B),
				new Piece(1, 7, PIECES.PAWN, [], COLORS.BLACK, SVG.POWN_B),

				
				// Ranks 6â€“3 (empty)
				undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,


				// Rank 2 (white pawns)
				new Piece(6, 0, PIECES.PAWN, [], COLORS.WHITE, SVG.POWN_W),
				new Piece(6, 1, PIECES.PAWN, [], COLORS.WHITE, SVG.POWN_W),
				new Piece(6, 2, PIECES.PAWN, [], COLORS.WHITE, SVG.POWN_W),
				new Piece(6, 3, PIECES.PAWN, [], COLORS.WHITE, SVG.POWN_W),
				new Piece(6, 4, PIECES.PAWN, [], COLORS.WHITE, SVG.POWN_W),
				new Piece(6, 5, PIECES.PAWN, [], COLORS.WHITE, SVG.POWN_W),
				new Piece(6, 6, PIECES.PAWN, [], COLORS.WHITE, SVG.POWN_W),
				new Piece(6, 7, PIECES.PAWN, [], COLORS.WHITE, SVG.POWN_W),

				// Rank 1 (white back rank)
				new Piece(7, 0, PIECES.ROOK, [{x: Infinity, y:0}, {x: -Infinity, y:0},  {y: Infinity, x:0}, {y: -Infinity, x:0}], COLORS.WHITE, SVG.ROOK_W),
				new Piece(7, 1, PIECES.KIGHT, [{x: 2, y:1}, {x: -2, y:1}, {x: 2, y:-1}, {x: -2, y:-1} , {y: 2, x:1}, {y: -2,x:1}, {y: 2, x:-1}, {y: -2,x:-1}], COLORS.WHITE, SVG.KNIGHT_W),
				new Piece(7, 2, PIECES.BISHOP, [{x: Infinity, y:Infinity}, {x: -Infinity, y: Infinity},{y: -Infinity, x:-Infinity}, {y: -Infinity, x: Infinity}], COLORS.WHITE, SVG.BISHOP_W),
				new Piece(7, 3, PIECES.QUEEN, [{x: Infinity, y:0}, {x: -Infinity, y:0}, {x: Infinity, y:Infinity}, {x: -Infinity, y: Infinity}, {y: Infinity, x:0}, {y: -Infinity, x:0}, {y: -Infinity, x: -Infinity}, {y: -Infinity, x: Infinity}], COLORS.WHITE, SVG.QUEEN_W),
				new Piece(7, 4, PIECES.KING, [{x: 1, y:0}, {x: -1, y:0}, {x: 1, y:1}, {x: -1, y: 1}, {y: 1, x:0}, {y: -1, x:0}, {y: -1, x:-1}, {y: -1, x: 1}], COLORS.WHITE, SVG.KING_W),
				new Piece(7, 5, PIECES.BISHOP, [{x: Infinity, y:Infinity}, {x: -Infinity, y: Infinity},{y: -Infinity, x: -Infinity}, {y: -Infinity, x: Infinity}], COLORS.WHITE, SVG.BISHOP_W),
				new Piece(7, 6, PIECES.KIGHT, [{x: 2, y:1}, {x: -2, y:1}, {x: 2, y:-1}, {x: -2, y:-1}, {y: 2, x:1}, {y: -2, x:1}, {y: 2, x:-1}, {y: -2, x:-1}], COLORS.WHITE, SVG.KNIGHT_W),
				new Piece(7, 7, PIECES.ROOK, [{x: Infinity, y:0}, {x: -Infinity, y:0},  {y: Infinity, x:0}, {y: -Infinity, x:0}], COLORS.WHITE, SVG.ROOK_W),
			];


		class Game{
			board; activePiece; turn; score
			

			constructor(initialBoard){
				this.board = initialBoard
				this.cells = [];
				for(let i=0; i<CELLS; i++)
					if(initialBoard[i])
						initialBoard[i].toGame(this)
				this.turn = COLORS.WHITE
				this.score = 0
				
			}

			
			renderBoard(){
				const boardElement = document.getElementById("board")
				boardElement.style.width = 8*CELLSIZE
				boardElement.style.height = 8*CELLSIZE

				let col = 0
				let row = 0;
				
				for(let i=0; i < CELLS; i++){
					col = i % 8
					row =  Math.floor(i / 8)

					const cell = document.createElement("div")
					cell.style.width = `${CELLSIZE}px`
					cell.style.height = `${CELLSIZE}px`
					cell.style.position = "absolute"
					cell.style.left = `${CELLSIZE * col}px`
					cell.style.top = `${CELLSIZE * row}px`
					cell.style.backgroundColor = (i+row)%2? "#666666": "#133666"
					cell.style.borderColor = "black"
					cell.style.borderWidth = 2
					cell.style.display = "flex"
					cell.style.justifyContent="center"
					cell.style.alignItems="center"

					if(this.board[i])
						this.board[i].render(cell)
					boardElement.appendChild(cell)

				}
					
			}	

			rednerScoreBoard(){
				const boardElement = document.getElementById("board")
				const scoreBoard = document.createElement("div")
				scoreBoard.style.position = "fixed"
				scoreBoard.style.backgroundColor = "white"
				scoreBoard.style.top = `${8 * CELLSIZE + 15}px`
				scoreBoard.style.left = `0px`
				scoreBoard.style.width = `${8 * CELLSIZE}px`
				scoreBoard.style.height = `${CELLSIZE}px`
				// scoreBoard.style.
				boardElement.appendChild(scoreBoard)


			}

			start(){
				this.renderBoard()
				this.rednerScoreBoard()
			}
		}

		const game = new Game(INITIAL_BOARD_STATE)
		game.start()

	</script>
</html>
		
